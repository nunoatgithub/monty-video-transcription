Jeremy Shoemaker: I'm Jeremy Shoemaker, a staff software engineer at the Thousand Brains Project, and I'll explain how to go through the pull request process and contribute code and related materials.

An overview of making a code contribution: Most changes are made in the tbp.monty repository, so you'll need to fork it on GitHub, set it up locally for development, and sign the contributor license agreement, which is typical for open source projects. You can read the details of the agreement. Make your changes in a branch on your fork, open a pull request, and the engineering team will triage it and assign it to a maintainer for review. You'll work with them until they're ready to approve it, and if the tests pass, a maintainer will merge the PR. All the details on this process are in our documentation, which covers more than I will here, but I'll go over the broad strokes. Documentation updates are also code contributions, so if you see a way to improve or add to the documentation, please do. Nearly every page in the documentation has a convenient "Make Contribution" link that opens an editor in GitHub for quick fixes. 

The first main thing you need to do is sign the CLA. This is done in a separate repository; you go there, open an issue, and sign the contributor license agreement. You can read it—it's standard and allows us to distribute your changes and gives us permission to do so.

Making changes depends on what you're doing; different tasks require different approaches. We have a style guide that covers our code style conventions. Code formatting is usually handled automatically with Ruff. We have a specific style for docstrings. There's also a code organization guide that explains how we use Python's object-oriented programming features, and which ones we avoid to keep things simple. You can review that document to see how your changes might fit in. We also have a typing guide describing our approach to type hinting. We don't currently run type checking because our codebase lacks complete coverage, but as we make changes, we add type hints to improve support.

Pull request triage is handled by the engineering team, which rotates weekly; currently, it's just me and Tristan. At least once a day, we review all open pull requests that haven't been triaged and assign them. We check that the title matches our conventional commits format, as described in our documentation, and ensure the description explains the change clearly. This helps us reference the PR later and understand the reasoning behind it. We review the changes to determine who on the team should review them and assign one or more maintainers as assignees. Note that we use the assignees field, not the reviewers field, to determine if a PR has the necessary maintainer approvals. Even if multiple reviewers approve, the assignees must approve the PR.

We use Ruff for style checking. I recommend setting this up to run on save in your editor; VS Code and other IDEs support this. Running Ruff check fix-sfix will automatically fix many issues, and Ruff formatting ensures code matches our style. You can also set these up in a pre-commit hook, but I find it less useful since it runs after changes are made.

You can run our test suite locally from the top-level directory by running pytest, which executes all tests. There are various options, but this runs the full suite. Tests also run in GitHub when you make a PR; if they fail, you'll be notified and need to fix them before merging. We have benchmark experiments to augment our test suite and provide more coverage. These can be run locally, and Hojae discussed earlier how to run an experiment; instructions are in our documentation. For changes that might affect benchmark results, maintainers run the full suite in our AWS infrastructure to check for unexpected changes. This may require further changes to resolve any differences. The documentation details the benchmarks, the experiments, and includes tables of expected results, which are updated when significant changes occur.

Our review process is typical. We use squash merges, so don't worry about messy commit histories—they'll be squashed. Please avoid using Git Rebase or other history rewriting, as it complicates reviews. Work with the assigned maintainers to get the PR approved; once approved, a maintainer will merge it. Some changes require benchmark runs, and the maintainer will run them, post results, and proceed as needed. Once all assignees approve, a maintainer merges the PR, and your code change is complete.

Thank you to everyone who has contributed and to future contributors. We appreciate your work, and contributions are recognized in our community shoutouts and monthly review videos. Now, I'll hand it over to Tristan to discuss how we plan to evolve Monty into an easy-to-use platform.
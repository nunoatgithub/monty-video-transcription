Jeremy Shoemaker: So yeah, I'm Jeremy Shoemaker, I'm a staff software engineer at the Thousand Brains Project, and I'm going to explain how you can go through the pull request process and contribute code and other related things.

So yeah, so an overview of making a code contribution. Most of our code changes are made in the tbp.monty repository, so you'll need to fork that on GitHub. You'll need to set it up locally for development, and then you'll need to sign the contributor license agreement, which is pretty typical of open source projects. You can go read the details of that. Then you make your changes in a branch on your fork and open a pull request, and then the engineering team will triage it and assign it to one of the maintainers to review, and then one or more of the maintainers, and then you'll work with them until they're ready to approve it, and then if the tests pass, one of the maintainers will merge the PR. What, So all the details on how this process works is in our documentation. You can get more details there than I'm going to cover, but I'm going to cover the broad strokes here. Also, documentation updates are code contributions, so if you think there's a way you can improve the documentation or add something to make it better, please do And pretty much every page in their documentation has this nice, convenient link where you can click "Make Contribution", and it'll open up a editor in GitHub to let you just make a change there. quick fixes are really easy to do. So the first main thing you need to do is sign the CLA. This is done in a separate repository. You just basically go there, open up an issue, and do the sign contributor license agreement. You can read it, it's pretty standard. It basically lets us, distribute the changes you've made and gives us permission To do all that stuff.

Making some changes. Depending on what you're doing, different things will require different chain... different, approaches, but, one of the things I want to point out is that we have a style guide that kind of goes through the different code style things we do. Code formatting is usually done automatically with Ruff. We have a particular style for how we do our docstrings. Another thing I want to call out here is that we have a code organization guide. Which documents how we want to use Python's object-oriented programming features. Some of them we don't want to necessarily use, because they make things more complicated than they need to be, and so there's a nice document there that you can go through and figure out how that might fit in. And then we also have a typing guide, which describes how we want to apply type hinting. We don't currently actually run any type checking because our codebase doesn't have complete coverage. But as we're making changes we're trying to add in type hints so that we can eventually get a nice approach and support there for type hinting. So how we triage the pull requests is that the engineering team rotates weekly on who handles triage, and currently that's just me and Tristan, and so it alternates. And at least once a day, we'll go through and look at all the open pull requests that haven't been triaged and then assign them out. And it usually involves checking the title to make sure it matches our conventional commits format which is in our documentation. You can look there in the code style. Making sure the description adequately explains the change. That way we and when we reference back to it we know what was going on and what the thinking was behind it. We'll cursorily look at the changes to determine who on the team would be best to review the changes and then assign one or more maintainers based off that to the assignees. One thing to note here is we use the assignees field, not the reviewers field, to determine if PR has the approvals it needs for a maintainer but from the maintainers of the project. So even if you've got multiple reviewers that have approved it, it has to be the assignees that approve the PR. As I mentioned before we use Ruff for style checking. I recommend you set this up as an onsave thing in your editor. You can do this in VS Code, and other IDEs have this as well. Running Ruff check fix-sfix will actually fix a lot of these automatically. And then rough formatting to do just general code formatting to match our style. You could also set these up in a pre-commit hook but that's Less useful in my experience because it's after you've been making the changes and you have to go back and do it again versus just running it when you save stuff. You can run our test suite locally from the top-level directory of the repository. Which is just running pytest and it'll run all the tests. There are various options you could add there, but that'll basically run the full suite. These are also run in GitHub anytime you make a PR so if they don't pass there you'll get a notification and have to be fixed before we can merge it. We also have a set of benchmark experiments that we run to augment our test suite and provide more coverage. These can be run locally and Hojae discussed earlier how you can run an experiment and you can find the instructions that she mentioned in our documentation. For changes that we think could affect benchmark results, the maintainers will usually run the full suite in our AWS infrastructure to ensure that the results haven't changed unexpectedly. Sometimes that might require further back-and-forth changes to figure out what happened, what might have caused the differences, if they're expected or unexpected. The documentation goes into details about the benchmarks. Talking about what experiments we have, what they are, and then there's a couple of tables of the results that we expect to see currently. And that kind of gets updated whenever we make significant changes that affect the results. Now, the basics of the reviews process is pretty typical. We use squash merges so don't worry about a messy commit history because it'll all get squashed down. We ask that you please refrain from using Git Rebase or any other form of history rewriting because it makes it difficult for reviewers to review new changes. Because GitHub doesn't do a good job of letting you see the differences. And just work with the assigned maintainers to get the PR into a state that they'll approve it and once they do, They'll merge it. Some changes, like I mentioned, will require benchmark runs, and the maintainer will run it and post the results and go from there. Once all the assignees approve it one of the maintainers will merge it and then you've successfully made a code change. I want to say thank you to all the people who've contributed and anyone in the future who contributes because we really appreciate all the work and it really helps. And any of your contributions usually go into our community shoutouts and our monthly review videos so you get kudos there. And with that, I will hand it over to Tristan to discuss how we plan to evolve Monty into an easy-to-use platform.
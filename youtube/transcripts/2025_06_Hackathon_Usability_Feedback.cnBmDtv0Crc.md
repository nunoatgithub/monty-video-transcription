Okay, put a recording. we wrote down all our feedback in the hackathon code feedback document that's linked, and we all voted on what we're going to discuss. Looking two votes. Two votes. Two votes, two votes, 1 1 3 votes. Okay. So first item, so we're talking about is. I can't use my own sensorimotor ID convention and I have to split one sensorimotor into two that use top depth and RGBA suffixes. So this was, an example that I had to do here. Initially, I was just returning, From the environment state, I was returning a sensorimotor and it only had a patch, but I couldn't do it because patch depth and patch dot R-B-A-R-G-B-A were hard coded expectations for the sensorimotor state, even though, as you can see, it's just the fully coupled to each other. So there's some assumption that's built in here. So that's the. Problem that I encountered. Viviane, you have two other items above that seem to refer to the same issue. Which one are you? it's, I guess it's not the same issue, but there were two other that were referring to that they're confusing naming conventions of calling things Patch or Sensorimotor Module Zero and like implicit assumptions in other, places of the code that you're using those names, which seems maybe related. I guess one comment now that you showed this, code snippet is that I, totally agree that it's, a problem, but, it's only a problem I think if you are just customizing a certain part of the code. for example, when we wrote our hackathon project. we're able to return state with no RGBA or depth because we have ultrasound. So we just called it ultrasound, but that was possible because we also wrote custom sensorimotor module class that then expected those, that, then didn't expect those. I think the main place where it is. You probably encountered the issues in the depth to 3D locations transform, I assume. And in our project we didn't use that transform, so maybe that's why it wasn't as big of an issue. But yeah, I'm not sure. Did you, do you remember where it, where that ex expectation was set? That it has those two fields?

I think it was in the depth. Yes. Depths two, 3D if I'm, yeah. Yeah, that sounds right.

I can't remember where that, okay. Yeah.

I guess then the question is like, how general do we want that TRA transform to be? Generally that transform requires a depth channel to be able to do anything, and then it, its purpose is to transform the RGBA channel into, to return that in a different format. So it requires those two fields.

but then yeah, it wouldn't necessarily need them to be called exactly that. So we could, like in some other places, we have variables that you pass to the function that tell where you pass. what's the name of the field that I want to use for the dev channel?

yeah, the, and the other thing here, structurally, right? because you're given a dictionary and you're hard coding a key. that's the coupling, right? Like with what you just said. Yeah. and this pattern happens a lot in the code. So it just like feedback would be, avoid this pattern of Of magically knowing what property to access on an object that was passed to you. Just have whoever's calling you make it their responsibility to give you the right thing. Don't be, and especially like in a generic dictionary. So that's the pattern to avoid there. as to the, yeah, I had some questions about where the, how generic this transforms were supposed to be because they, they get my experiments so they get, specified here. So it's, like this thing, right? by the way, this is what I know. You've probably never seen this. This is what a flat, configuration looks like.

Never seen in the wild before. But, so in the transform, it tried to be the same for our ultrasound project this time too. I think that says a lot about usability and configurations. We both, the teams went with the flat config, the, so the dataset, so this is in, so this is, so this is what the other basket that was confusing to me. this is a dataset configuration. this. So there's a transform that's happening on the data set, and this happens inside, under git item implementation. so when the data, when we a, when we tell the data sets to give me a, thing, it gets an observation and state, and then it transforms the observations themselves.

Shouldn't this be happening in like sensorimotor module or something like that? Yeah. So for a bit of context or history, first I'm not happy with this and I agree with you that kind of by how we think about Sensorimotor module, this should be happening in the sensorimotor module to. Kind of to transform, incoming data into the CMP and get the world coordinates. The reason why we have this kind of data set up that then applies transforms is because when we first started out writing this code base, we wrote it using kinda 10. torch Conventions and in Torch they have like dataset and data loader and transforms, and it's exactly that kind of setup. And the original idea was that this will make it really easy to then just plug in a deep learning system and compare to that. But we never really did that. We did it with, I think, vector neurons once, because like deep learning systems aren't really made for interacting with environments and learning continually. And we, we, are, not learning from static data sets, so we set up the repository to be made for static data sets, even though we are not working with that.

so yeah. Long story short, I'm not a fan of it. Okay. So, this, so to me what I'm hearing is, this sounds okay, so the transforms themselves will become part of the sensorimotor modules. That's part of the refactor of going away from dataset, data loader and just finding a different place for them. Yeah, that makes sense. I'm tracking that then. Yeah. Yeah. Okay. I was gonna say, yeah, we already have that noted somewhere, otherwise. Yep. Wanna make sure we.

Does anybody else wanna discuss any of this further? Okay. Let's go to the first one with two votes. Hojae and Jeremy voted for Embodied Environment as abstract classes that seem too specific to simulators. Add object, remove objects. Close. Gonna share maybe a screen too. I was fa, I just happened to be familiar with the previous one. The screen. Let me know. Better discuss this or.

Yeah, I think I added this, item because when I was customizing the embodied environment, I had to write these cla boil up plate classes. 'cause they're in the abstract class, even though they're just for Habitat made for habitat.

and I, might have been the one who actually added it, but I don't remember why it should be part of the abstract class. And I think it. Should not be.

but I, ran into very similar thing. again, please, if you wanna show your code go ahead. I just remembered working on this as well, environments.

so I think I, yeah, so I just skipped the, that environment, I think, right? Because the problem here was. But environment has abstract classes seem to, specific to simulators, yeah. So I just inherited directly from Embodied Environment because I didn't want that add object stuff. so when I, so we implemented everything. It's also environment. We just went directly from Embodied Environment. Hang on. But, maybe I'll share my, so what we have Yeah, please. Was, Also inherit from embodied environment, which I think is the abstract class, but then it requires you to implement. Oh, yeah. I, see it. Object. Race, not implemented error. Ultrasound environment does not support adding objects. And I saw this pattern in couple of other c custom environments too, that are not Habitat.

oh yeah. I just scroll down and I see I. I put raise, not implemented error. I just myself here, like I Okay. I don't think you shared, so I'll reshare again. yeah. This is what you're talking about. Yeah, exactly. We just needed to raise, implement, implemented error. Okay. Yeah, so that's just, it's too coupled too.

yeah. This fun. Yeah. It's, it feels like. This is definitely a sims, simulator. So maybe there's, it's just coupled to a simulator too soon. maybe there's a more generic environment. Yeah. 'cause I think we have a habitat environment class that inherits from embodied environment and I feel like that would be the place to have those, or to, yeah. Or have a simulated environment class.

Yeah, that strong of a requirement. what, it goes jumping into my head is we probably just should have environment and then there's simulated environment and then maybe embodied environment. And those are like the, simulated one has, you can add objects to it versus the embodied environment maybe has something to do with other things like positioning you in, a place or something like that. Okay. That makes, this makes sense to me.

see my notes. Yeah, I don't dunno. Notes. Jeremy, if you had some comments on that since you put your name there. Think mine was more around just the general, that's something I've seen in a lot of places of stuff being too tied to simulation environments and, kinda we discuss that more. But this is, good.

Although looking at that pattern that y'all did in both of those, reminded me of I've never actually used abstract based classes. Like we never used that in Bitbucket. what we would do is we'd have a base class and then manually implement the methods and have them throw not implemented, and usually have it pull the name of the class off. So if you sub classed it, it would still give you the message saying, this is the class that doesn't implement this. and that might be something you could do here is put, make those methods optional, really.

But I think I like, I think I like the idea of embodied versus simulated a little bit better than that. Yeah. So in my mind, the reason we have these abstract classes is because. We want Monty to be this very modular and customizable system where you can just write your own learning module and plug it in with all the other existing components without changing other stuff. And so having the abstract class gives you the boilerplate of these are the functions that the other component expect this class to have. And makes it a bit clearer to alright, I wanna write my custom learning module, so I need to implement those five functions. but yeah, I'm not a, what you describe is exactly like a protocol, actually. Like protocol is. Yeah. So yeah. Yeah. Basically defining, The kind of interface of that. The template. Yeah. The, difference between abstract class and a protocol will be abstract. Class will fail upon nationalization versus protocol will fail at runtime. Yes, I understand. So that's the, trade off. It's arbitrary where we do it depending on our tooling. For protocols to be useful, we need the. Developers need to have, type checking, say tooling implemented as part of code development. Yes. which I don't think we should do right now with lower versions of Python and even the latest version typing is still changing a lot. So anyways, yeah, I think I put it for the same reason as Jeremy.

I had one more thing to say, but now I forget what it is. I thought that abstract based class, just correct me if I'm wrong, is it, also partially used for tests like, so I don't know testing very well, but there I know something about like mocking objects or something like that. Like I know there's some fake buffer, fake agent thing. Does that do those require abstract classes or no? No. Okay. You can mock any class. Okay. Generally in Python, it's all duck typed, right? Like you just call it, and if the method's not there, you get a attribute error or whatever. this sort of like abstract class is more of a more strongly typed language type of thing. Okay. The, fakes aren't there to wrap abstractions, it's just to provide fake implementations for, the purpose of testing. But PS would be there without the abstract classes as well, just so they could be help the test. All right. Thank you.

All right. yeah, and in my mind, I, guess I still see a lot of value in having the abstract classes for now, because it's all in one place. It tells you, all right, this, is what is expected of this class. An environment should, implement a step function, a reset function. And, I don't know, the pre and post episode function, and it, and then you just see it all in one place. we could add a little bit more documentation to what, these functions should do or something like that, but yeah. Yeah. No, I agree. I think it definitely has value and I think just as you guys have identified it, maybe just needed to be made more abstract and then Simulated environment or whatever has these kind of more specific things.

okay. It's, let's move on to the next thing with the two votes, which would be this one?

There are multiple libraries used for defining orientation, SciPi. Rotation, quans. They use different qua conventions. It's like a, I'm laughing 'cause we have our slack threads on this just now too. Ordering of, they use d ordering of quan.

this is scaler last or scaler first. W being the scaler X, Y, z. Being the imaginary can be confusing may to errors. Rami Hojae, whoever wrote this, discuss. Oh, I just think that they, the order is, slightly different from also the problem of having multiple libraries that are doing the same thing. I don't know why we have, SPI rotations and also we have just, IANS that are like, it's, they seem, IANS seem to be defined in earlier parts of the code where, we had the, habitat simulation stuff. Maybe it requires it, I'm not sure. But, so the NIA package is like an extension of mpa so that it would allow for, I think it, it's like a very janky one. I actually looked into this and I wanted to get rid of it. 'cause I think we only use it in like a few places. I think. I think we use it in the interface with Habitat. Yeah.

They did? I'm not sure, I think Louis wrote that part of the code. I think it does, but we could probably put it even further towards just the interface with Habitat. Yeah. I'm not sure actually 'cause I know Habitat has, I feel like they have their own Coran thing, which they've is in their kind of c plus or whatever implementation. So I don't actually know if it is. Essential. I, don't think an appetite requires it, but I think we have it so that, it will, I think it's just a matter of us using that or us just transposing things to put it in the right order. So like we may be able to get rid of the. Dependency, at the cost of clarity, clarity as in okay. that package will say it's in this format, but, we just manually implement it in some sense. I, don't exactly know, but, all but my, my, I guess reason for putting it on was just like, let's decide on ordering at least as a group, and so that we can at least Stick with it. So everything will be converted to that. so that everybody knows that anything that comes out of Monty will also be in that ordering. And if they have to visualize using OpenGL, they will know, okay, which ordering I'm getting and which, if I need to transport transpose or not.

like I so open. Yeah, I think it, yeah. Yeah. So from, So I know OpenGL and Blender, so I think it's like visualize visualization tools and game like Unity use XY, ZW. while like science libraries, like ROS SciPi use, WXYZ, wait, doesn't, isn't SciPi XYZW and MPA is WXYZ. Oh, sorry. I might be forgetting. it's like it's already confusing. yeah. yeah. 'cause I think. Jeremy, you made a good point on Slack, like the more intuitive way is to have W first, but if sci-fi is the main thing we're using and that's like everywhere in the code, then we should probably stick to that convention. And I guess the main other instance we might use it is what you just raised, Hojae, which is like 3D graphic software when we like exported stuff. So maybe we say X, Y, ZW, but then just make sure it's really clear. my, my vote goes for WXYZ still. 'cause I think you can, as in an argument to yeah, okay, the, array that I'm giving is an WXYZ. I think it's worse. Okay. If we could do that, that, that's actually really nice. 'cause Yeah. Then we could do WXYZ and then we could also, it would be very clear every time you're calling SciPi, this is the convention that's being used. Yeah, it has. So even someone who doesn't use SciPi would, know. Yeah. Has a scaler first equals true would be the key word to add. That sounds, yeah, like a nice approach. Yeah. The reason why I'm going for WXYZ is just it's easier to do math.

yeah, no, I agree. It's definitely better from that. I just didn't want us to have to, every time we call SciPi, it'd be like, I, dunno, but yeah. But no, that argument sounds, like flag sounds perfect. Okay. But it also the balance is that I think that having it easier for math is more important than having it easier for like visualization. So if, if you have a strong case that like, okay, visualization is the main issue or more difficult to solve, then okay, I'm like, sabotaging myself, but I'm open to that devil is advocating myself. no. Yeah, no, I don't think that's that important. I just go ahead. Oh, yeah. My only remaining concern would be if it adds any computational overhead to have to keep converting. But as far as I remember, we just get the coran from the observations and then, once we're in, like inside the learning module, we don't work with coons anymore, which is where all the heavy lifting is happening with rotations. so it shouldn't be too big of an issue, even if we have to convert once. Yeah, I think even, I, think transposing is, I'm not saying it, it's nothing, but I think it's like not on top of what's slowing things down. yeah, if we would have to do it for a thought 10,000 hypotheses that we're testing, it might add up, but. Yeah. When we are testing our es, we're working with rotation matrices, so shouldn't be an issue. Yeah. And I would be surprised if sci-fi supports an argument for it, that they don't handle it relatively gracefully. Gracefully, but Okay. I think the person this must immediately will impact this. Jeremy as he's working towards Muko work, so you might have to mess around with, that one looks like it's WX, YZ as well. Yes.

Cool. Another password for Muko, our code.

Oh, not in this meeting, but I'm excited to tell you what we're doing with Monty to make it work with Maka. Jeremy should give a presentation at some point about what we're thinking. 'cause that's all sorts of exciting. Okay. Exciting. In a good way. It's, a little, almost now it's in a good way, but, you'll feel very, yeah. It sounded very obvious what we're doing with Monte. It's a, this was a teaser. Okay. Trailer. This is a teaser for a trailer. Trailer is coming later. So Sounds great.

okay, next two vote item is some abstract classes. Are these needed for testing?

may simply for code, if not also, multiple inheritance makes things harder to understand more and more difficult to extend by other users. I think more often than not.

So I added this per, I think this is address. yeah. so yeah, I added this, but this is address in the sense that, so abstraction, I think like promotes stronger coupling compared to vertical, or other things. But yeah, so that, that's why like I, add this. But I think we also talked about this. What are your reasons for putting in, putting your names.

I think we already have this in the kind of undesirable things, but I just thought it was worth kinda resurfacing that like right now with the different types of learning modules and graph, classes and stuff like that, it's really hard for new people I think, to read the code or even people who are familiar with it. and that a lot of that could probably be collapsed down into. Yeah, like that, would be one approach, just collapse everything down into a couple layers of inheritance. And then I guess a more extreme thing would be maybe trying like a more modular approach.

but, yeah, sorry. Okay. Which was not really discussed, I don't think, but yeah. Okay. So I wrote after Ness, and then my mind went to another thing about multiple inheritances. So it's, so the abstract part is. address that, that part is fine actually. the, yeah, the multiple inheritance. I think Niels and I like, experienced this when we were trying to write like a data loader for DMC. it was a crazy kind of Gotcha. You need to, yeah. Yeah. when, okay. Let me, I wanna ask a clarifying question. When you say multiple inheritance, do you mean.

Multiple levels. Height. Yes. Okay, so that's not multiple. That's okay. So sorry. Yeah, it's, this is the intent inheritance hierarchy. I'm gonna switch that. Thank you. Yeah, because that's also what I was thinking of. Deep inheritance hierarchy. So for, correct, for the learning module. I think we addressed this already. Neil, when we did the refactor like two years ago. Before we had all the learning modules inheriting from each other. Like we had the abstract test and we had the graph learning module, then the displacement graph learning module, then feature graph learning module, then evidence graph learning module. So it was like a six part hierarchy, and then we refactored it all. So it was just graph learning module and then the three types. From graph learning module each. Yeah. So there, I think we can flatten that hierarchy as flat as it can be for now, as far as I can tell. But I agree for some of the other classes, like the data loaders and, I think the, maybe the experiment classes too, still some more nesting that then might be necessary or policies, I'm not sure. Yeah. Yeah. maybe it's not necessary. I guess we could flatten that more if we got rid of the, feature and the displacement one. Like it's to maintain that ability to go lateral, that we still have that. But, but yeah, no, I take your point there. It's, definitely much better than it was. Yeah. So I think we just need to think about other Big classes, like besides learning modules, like just taking a look at the sensorimotor modules, how they're connected, taking a look at data sets and data loaders, how they're connected, and just go through the same process.

but, for what it's worth, I, my goal is for every inheritance hierarchy to be one level deep. You have an abstraction and you have instances of it and that's it. So everywhere I'm in code, I will be attempting to flatten the hierarchy to that always. That's my intent with policies and pro positioning procedures for example, like I do intend to flatten the policies and also to flatten the make your PO positioning procedures are flat.

so I think that, yeah, I think that makes a lot of sense. 'cause yeah, I think that's the challenge is as soon as you go. Deeper than that, it's when it becomes hard to think about.

for me it would be useful.

if it's not too much work to sometime have a meeting where you could just give some tips of alternative patterns to use. Because at least to me, like I kinda default to hierarchy sometimes when I'm like, oh yeah, I want to reuse this stuff from that class and just customize this function. So if you could just maybe. Present, what would be the alternative that, that would be better for us to use? A general quick first approximation answer will be a mixing. You have, you're trying to share some functionality, ripping it out as a so, if you have a class and there's a functionality sitting in there and you're like, I wanna reuse it, instead of going, I'm gonna make a subclass of it. Think of it, the functionality that you wanna reuse, how do I rewrite it as a mix in, then mix it into your original class, make sure everything still works, and then write a peer class and then grab that mix in and put it in there as well. that would be the general pattern to reuse functionality as a, Rami has been doing that recently, I think. Oh. about like mix. Is it, would it be easier to do something. Because so inheritance is like for me is, what's call it like, it's part of the class definition. So instead of passing as a class definition, like passing as a argument. So if I need some functionalities of. Let's say visualizer. I don't know, let's say that's a class. Then the argument is if the, if let's say my LM needs a visualizer, then like one way to do is to do, just pass in a visualizer instance as an argument and then just call, visit that whatever function we need from that class or. So this called, I think this's called like dependent injection, right? Something like that. Dependent, or positionality. Yeah. Com positionality. That's actually the better way. sorry, I was, my brain was stuck in Makes sense. what, how j say is the, probably the most preferred way is positionality especially, so I would go with what JJ said instead, as default I'll post And just to clarify the difference Exactly. So sorry. With the composition on how is it injected or. I know I, I'll post an example, it'll be much clearer. it's very easy to, I know this no, obscure term, but like it's actually very easy to understand, so I'll just post an example. It Slack. Yeah, that would be great. Nice. It, yeah, I was trying to think something on the code base, but my mind is blanking, so sorry.

So with the very first, the question on the top, you suggested for the abstract class to have a another class that's like simulator environment from which then I assume some other class would inherit. Is that a case where you would say hierarchy is better? 'cause it makes it clear to distinguish distinguished types of classes? Or would you also use composition there? I would. So environment would be abstract. Simulated environment would be specific, like concrete and that's it. Yeah. Nothing inherits from simulated environment flat. So then if I wanna have a habitat environment, what would I do? you would create a habitat environment. So what, does sim, what does simulated environment for, it sounds like it's like general to any simulator. I think this is, This is an abstract, right? I might have misspoke. Like we have an abstract environment, an abstract simulated environment, and then habitat would be a concrete implementation. This so as in simulated environment does not inherit from gen generic environment. Yeah. Maybe that's, maybe there's an environment protocol I don't snow. we have to think about it. Okay. But that's a good, that's a great example of, yeah, so it's Specifically, what would we do to implement Habitat environment? Yeah. Yeah. I don't know if this is, if this is like a standard or, Yeah. It'd be, interesting to look into this more, but it feels if the second level of inheritance is still abstract, as in it's not implementing methods, but it's just defining them, it still feels like that's easy to read. As in, I could imagine, yeah. We, us having this very abstract environment, which covers everything, including simulated environments and maybe robotic funds or whatever. And then we have simulated environment, which is oh, you should have ad object, all this kinda stuff, but it's all not implemented. And then, so technically there's three levels, but then it's the third level that implements everything concretely. But at least when you're reading the third level. Going up a level isn't you're not having to understand what a function is actually doing. Going up a level is just telling you this is the structure, this is the skeleton, of, this class and going, and then having the top level tells you, okay, this is how it relates to other ones. But maybe it's not even helpful to have that top one. I dunno. Yeah. so thinking about answer is forming in my head because again, this is like a rule that. Really don't wanna break. And so what I maybe would do would be Habitat environment inherits from environment and it also implements the simulated environment protocol.

Okay.

It's, that makes it one deep, it just an environment. But simulated environment also has an additional protocol that these environments do. And then when we have an experiment class that would like an experiment class for running on a simulated environment, it would check whether our environment is following the simulated environment. has that in it. Okay. So if you, pass an environment to Yeah. Experiment, it's hey, this is not a simulated environment. What's wrong? Exactly. Yeah. Okay.

Cool. Thanks. Yeah, it's, I, just wanna highlight, just to really try not to break the rule with forces this, these types of solutions which end up being more intuitive. So it's like when you hit a wall of a rule, just don't give up on the rule just yet. Like it, it'll guide you to a solution. That's how I feel. What happened here. I was just like, once we say, no, let's keep this one level deep. How else can we solve the problem? And that should help. And so the reason why this is preferred is because it's probably just familiarity for me, but it, still seems to me if it's a hierarchy, it's easy to follow the path versus if there are like multiple things in there, I have to there's like a fork and I have to decide where I want to go first and I have to come back and then I have to go to the other place to see what's there. so I feel like, I could make the argument for it being harder to follow. Yeah. Niels and Hojae said the opposite. for me it's, the difficulty is if, yeah, like kinda what I was saying before, I feel like if the parent class is also like making concrete implementations of methods, I think that's when it's more likely to get confusing because then it's like some things are calling like super and some things aren't, and there's just like a lot of back and forth. I feel like as long as the parent is still abstract and it's oh, okay, this. Parent one is just adding these abstract methods, which is what makes it unique. this is what makes it a simulator thing. I feel like that, yeah, but maybe like Viviane says, it's also just familiarity that would be equally easy to read and understand. I feel so happy to stick to the rules and also when you're like, when it starts not to make sense, just let's you know. Ping me, ping Jeremy. Let's have a conversation. It'll be much easier. It's somewhat, difficult to dish out this generic guidance. It's like much easier to do it specifically on the problem because then it's EAs, then it's easier to provide a solution for a specific instance of what is happening, than to talk in generalities and then apply them.